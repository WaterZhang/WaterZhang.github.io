<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寻找水世界</title>
  
  <subtitle>纵容的 喜欢的 厌倦的 宠溺的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangzemiao.com/"/>
  <updated>2021-01-04T05:18:21.257Z</updated>
  <id>http://zhangzemiao.com/</id>
  
  <author>
    <name>寻找水世界</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021开篇</title>
    <link href="http://zhangzemiao.com/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/2021%E5%BC%80%E7%AF%87/"/>
    <id>http://zhangzemiao.com/工作总结/2021开篇/</id>
    <published>2021-01-04T04:28:27.000Z</published>
    <updated>2021-01-04T05:18:21.257Z</updated>
    
    <content type="html"><![CDATA[<p>2020年末尾，公司给大家免费放了一周的假，再加上自己休了一周的年假。一起休息了大半个月，陪女朋友去了趟怀化，顺便还接受了一个公司的电话技术面试，回了一趟老家，错过了与长沙老友的相聚，结束了假期。</p><p>2020年，经历了公司裁员，CEO换帅，团队也发生了变故，小团队解散，只留下一半的同事，整体工作强度放缓。说句不好的，有点浑浑噩噩的就过完了一年，一声叹息，就此别过。</p><p>深知不能如此停下脚步，需要寻求工作上的改变和进步。整理工作上的积累，积极学习新的知识，继续更新自己的博客，记录心路旅程。希望2021，工作能有所改善，生活要稳步进行下去。</p><p>关于面试总结，应该会单独写一遍文章。在不影响目前工作的前提下，多出去面试，一边总结，一边进步和学习。</p><h2 id="计划2021"><a href="#计划2021" class="headerlink" title="计划2021"></a>计划2021</h2><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><h4 id="调整心态，谨言慎行"><a href="#调整心态，谨言慎行" class="headerlink" title="调整心态，谨言慎行"></a>调整心态，谨言慎行</h4><p>自己性格直爽，言语激励，2021年，要寻求改变，控制自己的脾气，提高心性。我改变不了别人对工作的态度，要改变自己，做好自己分内了，志同道合的，一起进步。接受不了别人的，或对别人不满的，尽量选择沉默，不允个人评价。对事总结，应该可以畅所欲言，有什么说什么。<br>尝试跟不喜欢的人相处，不行就沉默。</p><h4 id="加强时间管理"><a href="#加强时间管理" class="headerlink" title="加强时间管理"></a>加强时间管理</h4><p>2021年，要多线作战，提高工作效率，加强时间管理。不仅要出色完成工作任务，而且要抽出时间，进行自我提升。</p><h4 id="多写文档多分享"><a href="#多写文档多分享" class="headerlink" title="多写文档多分享"></a>多写文档多分享</h4><p>开卷有益，多记录多分享。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><h4 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h4><p>恩，是该考虑了。</p><h4 id="控制游戏时间"><a href="#控制游戏时间" class="headerlink" title="控制游戏时间"></a>控制游戏时间</h4><p>尽量控制自己，压缩游戏时间。</p><h4 id="控制体重"><a href="#控制体重" class="headerlink" title="控制体重"></a>控制体重</h4><p>春暖开花，要考虑甩甩身上的肉了。领导要求我，减个20斤，试试看吧。</p><h4 id="人生大事"><a href="#人生大事" class="headerlink" title="人生大事"></a>人生大事</h4><p>恩，这是最重要的。</p><p>立下Flag，重新出发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年末尾，公司给大家免费放了一周的假，再加上自己休了一周的年假。一起休息了大半个月，陪女朋友去了趟怀化，顺便还接受了一个公司的电话技术面试，回了一趟老家，错过了与长沙老友的相聚，结束了假期。&lt;/p&gt;
&lt;p&gt;2020年，经历了公司裁员，CEO换帅，团队也发生了变故，小团
      
    
    </summary>
    
      <category term="工作总结" scheme="http://zhangzemiao.com/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工作总结" scheme="http://zhangzemiao.com/tags/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作计划" scheme="http://zhangzemiao.com/tags/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程指南</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhangzemiao.com/Java并发编程/Java并发编程/</id>
    <published>2020-11-30T16:00:00.000Z</published>
    <updated>2020-12-17T07:44:38.901Z</updated>
    
    <content type="html"><![CDATA[<p>这里汇总所有的并发编程的知识，整理出一个脉络清晰图，方便温故，查找。当然这只是开始，而非结束。</p><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p><a href="/Java并发编程/Java内存模型">Java的内存模型</a><br><a href="/Java并发编程/Java线程">Java的线程</a><br><a href="/Java并发编程/Java中的锁">JAVA中的锁</a></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="/Java并发编程/ReentrantLock实现分析">重入锁ReentrantLock</a>，重入锁用来替代Synchronized关键字，提供更灵活的方式。<br><a href="/Java并发编程/ReentrantReadWriteLock实现分析">读写锁ReentrantReadWriteLock</a>，分析读操作和写操作。<br><a href="/Java并发编程/ConcurrentHashMap实现分析与使用">新的ConcurrentHashMap</a>，Java 1.8中，已没有所谓的分段锁设计了，不妨看看。<br><a href="/Java并发编程/Fork-Join框架使用与分析">Fork/Join分解无返回结果任务</a>，大任务化解小任务，不需要返回结果，不需要汇总。<br><a href="/Java并发编程/Fork-Join框架使用与分析二">Fork/Join分解有返回结果任务</a>，大任务化解小任务，有结果返回，需要汇总。<br><a href="/Java并发编程/CountDownLatch使用与分析">CountDownLatch</a>，并发流程控制，应付需要等人齐（线程或者说是参与者），才干活（一起要做的事）的场景。<br><a href="/Java并发编程/CyclicBarrier使用与分析">CyclicBarrier</a>，屏障点设置，（线程或者说是参与者）等等，大家一起上。屏障点可以重复设置。<br><a href="/Java并发编程/Executor框架使用与分析一">Executor中的CachedThreadPool</a>，无限制创建线程，大吞吐量，风险很大。<br><a href="/Java并发编程/Executor框架使用与分析二">Executor中的FixedThreadPool</a>，固定的线程池，吞吐量固定，不具有弹性。<br><a href="/Java并发编程/Executor框架使用与分析三">Executor中的有返回结果的任务以及Future接口</a>，Future接口以及FutureTask实现，处理有返回结果的任务。<br><a href="/Java并发编程/Executor框架使用与分析四">Executor中的ScheduledThreadPoolExecutor以及延时任务</a>，延时任务的执行机制。<br><a href="/Java并发编程/Executor框架使用与分析五">Executor中的ScheduledThreadPoolExecutor以及周期性任务</a>，周期性任务的执行机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里汇总所有的并发编程的知识，整理出一个脉络清晰图，方便温故，查找。当然这只是开始，而非结束。&lt;/p&gt;
&lt;h2 id=&quot;理论知识&quot;&gt;&lt;a href=&quot;#理论知识&quot; class=&quot;headerlink&quot; title=&quot;理论知识&quot;&gt;&lt;/a&gt;理论知识&lt;/h2&gt;&lt;p&gt;&lt;a href
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如果我是招聘HR</title>
    <link href="http://zhangzemiao.com/%E9%9D%A2%E8%AF%95/%E5%A6%82%E6%9E%9C%E6%88%91%E6%98%AF%E6%8B%9B%E8%81%98HR/"/>
    <id>http://zhangzemiao.com/面试/如果我是招聘HR/</id>
    <published>2018-08-16T11:58:11.000Z</published>
    <updated>2020-12-17T07:44:38.908Z</updated>
    
    <content type="html"><![CDATA[<p>命题作文，急需一晚完成，明天假装当一回招聘。</p><h1 id="找人"><a href="#找人" class="headerlink" title="找人"></a>找人</h1><p>招聘HR上班第一天，不太会用各种简历库和网站，找资深小姐姐帮忙，寻找合适的简历。</p><h1 id="看简历"><a href="#看简历" class="headerlink" title="看简历"></a>看简历</h1><p>长得漂亮的小姐姐，可以免试。。。</p><h2 id="看背景"><a href="#看背景" class="headerlink" title="看背景"></a>看背景</h2><p>好的背景，等于好的起跑线，不得不承认，这是优势，看不见的是背后强大而丰富的资源和人。</p><h2 id="看学历"><a href="#看学历" class="headerlink" title="看学历"></a>看学历</h2><p>博士，不太可能忽悠来乙方，不要去想了，硕士好于本科，多忽悠。</p><h2 id="看英语能力"><a href="#看英语能力" class="headerlink" title="看英语能力"></a>看英语能力</h2><p>四六级证书有木有，有没有在外企工作的经历，有没有参加过什么英语活动？客户看中英语，还能咋办，优先推荐呗。再不济，提前让候选人准备一份英文简历，或者一段英文自我介绍。再不济，帮候选人准备一份英文介绍模板，让候选人背背，热热身，以备不时之需。</p><h2 id="看不看技术"><a href="#看不看技术" class="headerlink" title="看不看技术"></a>看不看技术</h2><p>浅显之见，没什么可看的，国内公司现在使用的技术框架，很相似。Spring体系，Spring MVC，Spring Boot，Spring Cloud等等。Dubbo加ZooKeeper做分布式，再加一个MQ，比如Active MQ，再加一个内存数据库Redis。</p><h2 id="看文采不"><a href="#看文采不" class="headerlink" title="看文采不"></a>看文采不</h2><p>恩，会写好文章的厨师，不是好程序员。言简意赅的简历，我喜欢。</p><h2 id="客观VS主观"><a href="#客观VS主观" class="headerlink" title="客观VS主观"></a>客观VS主观</h2><p>这个就有点难度了，把主观描述的字眼，全部趴掉，看剩多少内容。是骡子是马，脱光他，走两步，瞧瞧。<br>好简历，坏简历，这会儿应该可以看出来了。感觉对于乙方，是不是不用刷选简历啊。。。<br>对于是否专业出身，多说两句，英雄不问出处，但是对于转行做IT的，套路一下为什么入坑，如果回答是喜欢，我觉得可以。如果回答是因为本专业辛苦，为了钱干IT，恩，我觉得不可以，起码可能不会优秀，底子又差。<br>一个主动，一个被动。</p><h1 id="撩汉即正义"><a href="#撩汉即正义" class="headerlink" title="撩汉即正义"></a>撩汉即正义</h1><p>简历刷选出来了，可以撩一撩了。</p><h2 id="薪资期望"><a href="#薪资期望" class="headerlink" title="薪资期望"></a>薪资期望</h2><p>不超公司高压线就行。</p><h2 id="够自信么"><a href="#够自信么" class="headerlink" title="够自信么"></a>够自信么</h2><p>对于自信的人，不用多撩了，问他嘛时候有空，过来跟面试官PK一下。</p><h2 id="不自信，那诚实么"><a href="#不自信，那诚实么" class="headerlink" title="不自信，那诚实么"></a>不自信，那诚实么</h2><p>对于憨厚老实的人，要多撩一下，多问一下问题，看逻辑思路清晰么？问问下面的问题，增加一下自己的判断。</p><h2 id="怎么学技术"><a href="#怎么学技术" class="headerlink" title="怎么学技术"></a>怎么学技术</h2><p>靠百度混的，渣渣，该鄙视。<br>逛论坛，太low了，不好。<br>经常翻墙，这有戏。。。<br>看书，这有戏，最近看什么书，撩一撩，问问学到了什么？从语气看是否有底气，吞吞吐吐的，肯定没怎么看懂，当他是骗你的。<br>看官方文档，查资料，学习使用技巧，这有戏。。。我说的是英文文档。。。<br>关注大牛，这有戏，问问具体指关注了哪些，等后续跟面试官辩真伪。<br>看付费内容，比如极客时间，这有戏。。。有这操作，得骗，骗他公司有技术非常厉害的人，可以学到很多技术。</p><p>肯为学习而花钱的，别错过。</p><h2 id="要跟候选人聊技术么"><a href="#要跟候选人聊技术么" class="headerlink" title="要跟候选人聊技术么"></a>要跟候选人聊技术么</h2><p>我觉得不太好，起码直接问候选人技术，不太好。文人相轻，你个HR，还敢问我技术。。。<br>浅显的问题，容易百度，容易准备，也问不出什么深度。复杂的问题，作为不懂技术的HR，是很痛苦的。<br>即使要问，最好问一下候选人，能不能问一下技术？<br>技术是坑，深似海，建议不要入。完全可以通过其他方式，去评价一个人是否合适，是否优秀。<br>撩完了，还能存活的，可以约第一轮面试了。</p><h1 id="支援候选人"><a href="#支援候选人" class="headerlink" title="支援候选人"></a>支援候选人</h1><h2 id="知己知彼"><a href="#知己知彼" class="headerlink" title="知己知彼"></a>知己知彼</h2><p>通过刷选简历和先前聊天，确定候选人意向，并给候选人一个初步评价，然后制订作战方案，提出一些建议，让候选人去准备和热身。</p><h2 id="再知己知彼"><a href="#再知己知彼" class="headerlink" title="再知己知彼"></a>再知己知彼</h2><p>对于面试官，也有难搞和不难搞。画个圈圈”诅咒”一下难搞的。。。面试之前，可以告知候选人，面试官喜欢问哪些问题，要具体的，精确的问题，这是HR应该做的，要做的，而且要做好的。有心的候选人，会去准备一下。无心的人，活该失败。</p><h2 id="开卷有益"><a href="#开卷有益" class="headerlink" title="开卷有益"></a>开卷有益</h2><p>回到面试官的身份，可以提前跟候选人说，我会问各种HashMap问题。如果精通HashMap，可以给Mid Level。</p><h2 id="怎么搜集面试题"><a href="#怎么搜集面试题" class="headerlink" title="怎么搜集面试题"></a>怎么搜集面试题</h2><ol><li>从候选人那里得到反馈</li><li>旁听</li><li>尝试问问面试官</li><li>要精细的面试题，泛泛的没用</li><li>答案不是最重要的，思考问题才是</li><li>不要让面试官知道，你有在帮助候选人，避免尴尬</li></ol><h2 id="面试真的可以应付"><a href="#面试真的可以应付" class="headerlink" title="面试真的可以应付"></a>面试真的可以应付</h2><p>讲真，面试和工作，没有太多的联系。机会，留给认真准备的人。</p><h1 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h1><p>薇薇给我的问题，</p><ol><li>Java的常用框架（分类），以及每种框架更合适的项目类型（或者每种框架都相对常用在什么类型项目中）？</li><li>敏捷开发和分布式开发的优缺点（我们项目对于外面的传统项目的技术吸引亮点）、普及程度、以及发展前景？</li><li>SpringBoot、SpringCloud的理解与使用，目前常见于哪些类型的公司（项目）中使用？</li></ol><p>技术问题不回答，现在再问。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://od0tim0m3.bkt.clouddn.com/WechatIMG18.jpeg" alt></p><p>愿候选人，HR，面试官都能被生活温柔以待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">白发渔樵江渚上</span><br><span class="line">惯看秋月春风</span><br><span class="line">一壶浊酒喜相逢</span><br><span class="line">古今多少事，都付笑淡中</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命题作文，急需一晚完成，明天假装当一回招聘。&lt;/p&gt;
&lt;h1 id=&quot;找人&quot;&gt;&lt;a href=&quot;#找人&quot; class=&quot;headerlink&quot; title=&quot;找人&quot;&gt;&lt;/a&gt;找人&lt;/h1&gt;&lt;p&gt;招聘HR上班第一天，不太会用各种简历库和网站，找资深小姐姐帮忙，寻找合适的简历。
      
    
    </summary>
    
      <category term="面试" scheme="http://zhangzemiao.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://zhangzemiao.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="HR" scheme="http://zhangzemiao.com/tags/HR/"/>
    
  </entry>
  
  <entry>
    <title>Java技术面试反馈</title>
    <link href="http://zhangzemiao.com/%E9%9D%A2%E8%AF%95/Java%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%8F%8D%E9%A6%88%E6%A8%A1%E6%9D%BF/"/>
    <id>http://zhangzemiao.com/面试/Java技术面试反馈模板/</id>
    <published>2018-06-23T06:51:05.000Z</published>
    <updated>2020-12-17T07:44:38.901Z</updated>
    
    <content type="html"><![CDATA[<p>应HR要求，写一个技术面试的反馈标准，尽力而为。</p><h2 id="技术文档"><a href="#技术文档" class="headerlink" title="技术文档"></a>技术文档</h2><p>这是之前花了一个星期准备的<a href="http://od0tim0m3.bkt.clouddn.com/Java%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95-%E5%88%9D%E7%A8%BF.pdf" target="_blank" rel="noopener">技术面试文档</a>，仅为初稿版，轻喷。</p><h2 id="面试过程以及反馈文档"><a href="#面试过程以及反馈文档" class="headerlink" title="面试过程以及反馈文档"></a>面试过程以及反馈文档</h2><p>作为面试官，关注候选人对各种问题的应答，并给出相应的评估。个人不太喜欢太古板的面试，只要候选人有个别的亮眼的特点，就挺好了。</p><table><thead><tr><th>面试点</th><th>意图</th></tr></thead><tbody><tr><td>自我介绍</td><td>言简意赅，寻找亮点，问问特别经历</td></tr><tr><td>项目介绍</td><td>对最近的项目进行描述，对于项目的架构理解，衍生传统MVC，以及微服务，理解构架中的难点，以及是否对公司的架构有过优化</td></tr><tr><td>Java SE</td><td>个人经常问Collection框架相关问题，考察对数据结构的理解，研究学习能力，以及良好的阅读习惯，比如是否常看JDK API文档以及官方文档</td></tr><tr><td>Java并发</td><td>并发，作为Java的进阶技术，是否在工作中使用，是否在研究过并发原理</td></tr><tr><td>设计能力</td><td>在面试过程中，向候选人提问设计问题，比如JVM Cache如何设计，要考虑哪些问题</td></tr><tr><td>设计模式</td><td>项目中，有过的设计模式，除了传统的26种，还有没有别的”套路”</td></tr><tr><td>研究问题的深度</td><td>有没有研究过源码，有没有理解过相关的Java底层设计</td></tr><tr><td>算法能力</td><td>这个在我面试中，很少问及，面试官不准备，都很难。何况候选人呢，不推荐</td></tr></tbody></table><p>根据这些知识点，整理了一份<a href="http://od0tim0m3.bkt.clouddn.com/%E9%9D%A2%E8%AF%95%E5%8F%8D%E9%A6%88.docx" target="_blank" rel="noopener">反馈表</a>，仅供参考。</p><p>路漫漫，慢慢打酱油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应HR要求，写一个技术面试的反馈标准，尽力而为。&lt;/p&gt;
&lt;h2 id=&quot;技术文档&quot;&gt;&lt;a href=&quot;#技术文档&quot; class=&quot;headerlink&quot; title=&quot;技术文档&quot;&gt;&lt;/a&gt;技术文档&lt;/h2&gt;&lt;p&gt;这是之前花了一个星期准备的&lt;a href=&quot;http://o
      
    
    </summary>
    
      <category term="面试" scheme="http://zhangzemiao.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务及性能分析</title>
    <link href="http://zhangzemiao.com/Redis/Redis%E4%BA%8B%E5%8A%A1%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://zhangzemiao.com/Redis/Redis事务及性能分析/</id>
    <published>2017-02-27T08:34:42.000Z</published>
    <updated>2020-12-17T07:44:38.902Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章，学习了Redis进行持久化以及复制相关问题，继续学习，了解Redis的事务相关处理。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在不同的客户请求中，如何保证数据正确性，顺带要提升性能？</p><p>对于传统的数据库，做事务，我们先告诉DB，要开始一个事务Begin，然后执行批量的读写操作，最后提交事务Commit，使这些状态变化是永久性的，要不全部回滚。</p><p>对于Redis，开始“事务”使用MULTI命令，然后传递多个命令，最后跟上EXEC命令。这个过程中，我们需要等待EXEC命令调用，才真正做事，中间过程，不能做其他操作。（有点像延时执行命令）。这样处理的好处，是提升性能，减少网络负载（客户端和服务器交互）。缺点是中间过程不够灵活。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>WATCH，MULTI，EXEC，UNWATCH，DISCARD<br>WATCH，标记所有指定的key被监视起来，在事务中有条件的执行（乐观锁），我们使用WATCH命令后，其他客户来更新这些key时，会报错。这样确保，我们在做一些更新操作时，数据不会被串改。<br>UNWATCH，取消事务命令。<br>DISCARD，丢弃MULTI之后发出的命令。<br>EXEC，执行批量命令。</p><p>这里有<a href="https://www.zhihu.com/question/29397176" target="_blank" rel="noopener">悲观锁</a>的介绍。<br>这里有<a href="http://baike.baidu.com/link?url=EDNymMhkUMC8tL4Nhap_z5kuv9JSmG9Vl-amZw6lw2A6JyQ2EuKcxzyxgZcloxnlC9PLHsjVboM1t0nAjOVeDFpG_wbIQuw5BWPNJtkMEl0ZKdp3AhFy2e13KRhRHpmb" target="_blank" rel="noopener">乐观锁</a>的介绍。类似Java的AQS的CAS特性。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>Redis基准测试，<br>redis-benchmark -c 1 -q</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单介绍一下Redis中的“事务”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章，学习了Redis进行持久化以及复制相关问题，继续学习，了解Redis的事务相关处理。&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;p&gt;在不同的客户请求中，如何保证数
      
    
    </summary>
    
      <category term="Redis" scheme="http://zhangzemiao.com/categories/Redis/"/>
    
    
      <category term="NOSQL" scheme="http://zhangzemiao.com/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>迁移Hexo至MAC</title>
    <link href="http://zhangzemiao.com/hexo/%E8%BF%81%E7%A7%BBHexo%E8%87%B3MAC/"/>
    <id>http://zhangzemiao.com/hexo/迁移Hexo至MAC/</id>
    <published>2017-02-23T03:25:29.000Z</published>
    <updated>2020-12-17T07:44:38.909Z</updated>
    
    <content type="html"><![CDATA[<p>这是在Mac上写的第一篇文章。</p><h2 id="Mac平台"><a href="#Mac平台" class="headerlink" title="Mac平台"></a>Mac平台</h2><p>最近入手Macbook pro，买的2015年款15寸，2016款，一来贵，二来touch bar还不够实用。</p><h2 id="迁移Mac"><a href="#迁移Mac" class="headerlink" title="迁移Mac"></a>迁移Mac</h2><p>需要安装的软件，</p><ol><li>git及设置SSH</li><li>Node.js</li><li>Xcode(虽不做苹果相关开发，最好下载)</li><li>Hexo</li><li>加载博客的github项目</li><li>测试</li></ol><p>在加载博客的github时，遇到了一些问题，直接使用git remote加载项目时，不能正常启动hexo，折腾了许久，换成SourceTree工具，关联项目。nodejs相关模块，是没有同步至github的，解决冲突，然后下载各个缺省的模块，顺利搭起博客了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>安装完hexo后，总是出现各种问题，各种蒙圈，多尝试，多google，完事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是在Mac上写的第一篇文章。&lt;/p&gt;
&lt;h2 id=&quot;Mac平台&quot;&gt;&lt;a href=&quot;#Mac平台&quot; class=&quot;headerlink&quot; title=&quot;Mac平台&quot;&gt;&lt;/a&gt;Mac平台&lt;/h2&gt;&lt;p&gt;最近入手Macbook pro，买的2015年款15寸，2016款，一
      
    
    </summary>
    
      <category term="hexo" scheme="http://zhangzemiao.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://zhangzemiao.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据存储与复制</title>
    <link href="http://zhangzemiao.com/Redis/Redis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangzemiao.com/Redis/Redis数据存储问题/</id>
    <published>2017-02-17T08:38:26.000Z</published>
    <updated>2020-12-17T07:44:38.903Z</updated>
    
    <content type="html"><![CDATA[<p>介绍完Redis的基本命令，来看看Redis对数据存储的方面的设计。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis提供两种方式进行持久化，Snapshot VS AOF(Append-only file)。持久化可以解决数据备份和恢复的问题，还可以存储一些需要长时间计算的结果，节省开销。</p><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>BGSAVE命令，异常保存数据，主线程提供服务，子线程执行数据存储，<strong>Windows平台不具有fork特性</strong>。<br>SAVE命令，停止服务，专门进行数据存储至磁盘。<br>用例，</p><p>如果60秒内，有10000次写操作，会触发BGSAVE操作。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></p><p>shutdown命令，会停止所有客户端，如果有保存点，会执行SAVE命令，如果AOF选项被打开，更新AOF文件，最后关闭redis服务器。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHUTDOWN SAVE （强制让数据库执行保存操作，即使没有设定保存点）</span><br><span class="line">SHUTDOWN NOSAVE （阻止数据库执行保存操作）</span><br></pre></td></tr></table></figure></p><p><strong>全局备份（BGSAVE），耗时严重，fork会很慢，SAVE相对快，但阻塞用户请求。</strong></p><h3 id="Append-only-file"><a href="#Append-only-file" class="headerlink" title="Append-only file"></a>Append-only file</h3><p>进行Config设定或者配置<br>appendonly yes</p><p>appendfsync的选项，</p><ol><li>always ，每次写操作都写入磁盘，最大限度减少数据丢失。</li><li>everysec，每秒的写操都写入磁盘。</li><li>no，让OS决定什么时候同步数据至磁盘。</li></ol><p>通常来说，将文件写入磁盘，需要做三件事儿，一是创建缓冲区，二将数据写入缓冲区，三是将缓冲区中的数据写入磁盘文件。在使用always选项时要慎重，会减少磁盘的寿命。</p><p><strong>如果数据量很大，会导致AOF文件很大。致使磁盘空间不够，或者重启恢复数据非常慢。BGREWRITEAOF命令，可以重写AOF文件，优化该文件。</strong><br><strong>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发。</strong></p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>系统扩展，提升性能。<br>对于单个Redis服务器，想要在10毫秒内完成单个命令，我们需要限制每秒只有100个请求到单台服务器。（随便服务器的升级，单台的性能会有所提升，但还是会遇到瓶颈。）</p><p>Redis提供主从（Master/Slave）设置，写操作在Master执行，然后将数据实时同步至Slave服务器。客户端的读操作，在Slave服务器执行（多台，可进行负载均衡）。</p><p>slaveof host port，连接一个Master服务器，可以作为配置项，也可以当命令执行。<br>slaveof no one，停止主从关系。</p><p><strong>如果slaveof作为配置项，启动时，会加载snapshot/AOF，然后连接Master，开始复制过程。</strong><br><strong>如果在运行时执行slaveof命令，Redis会立即Master，开始复制过程。</strong></p><h3 id="复制步骤"><a href="#复制步骤" class="headerlink" title="复制步骤"></a>复制步骤</h3><p>复制过程，</p><table><thead><tr><th>步骤</th><th>Master</th><th>Slave</th></tr></thead><tbody><tr><td>1</td><td>等待命令</td><td>connect to master,发出SYNC命令（内部命令）</td></tr><tr><td>2</td><td>开始BGSAVE操作</td><td>用旧数据提供服务或者返回error（根据配置）</td></tr><tr><td>3</td><td>完成BGSAVE操作，开始给slave发送snapshot</td><td>抛弃旧数据，开始加载收到的dump文件</td></tr><tr><td>4</td><td>完成snapshot发送，开始发送写命令的backlog给slave</td><td>完成dump解析，开始正常响应请求</td></tr><tr><td>5</td><td>完成backlog发送，开始实时写操作流</td><td>完成写操作的backlog执行，收到写操作流，继续执行同步</td></tr></tbody></table><p>通常情况，我们需要考虑Master服务器的内存使用情况，建议内存使用率不要超过50%-65%，要预留足够的空间给服务器执行BGSAVE和backlog命令。还有Redis不支持Master-Master复制。</p><h3 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h3><p>对于Redis数据库，主从关系是相对的，可以形成一个主从关系的树结构。当应用有大量读操作时，我们建立的主从关系，应避免1对多的情况（服务器带宽以及性能限制），而是建立多层次的主从结构关系。</p><h2 id="处理系统错误"><a href="#处理系统错误" class="headerlink" title="处理系统错误"></a>处理系统错误</h2><p>Redis数据库无法跟传统数据库一样，提供ACID（原子性，一致性，隔离性，持久性）功能。</p><h3 id="命令恢复备份"><a href="#命令恢复备份" class="headerlink" title="命令恢复备份"></a>命令恢复备份</h3><p>当系统崩溃时，需要使用命令工具来恢复系统。<br>redis-check-aof [–fix] file.aof， 恢复aof数据，–fix帮助我们扫描aof文件，查找未完成以及不正确的命令，然后剪接文件，保证能够文件被执行加载。<br>redis-check-dump dump.rdb，恢复dump数据，目前还没提供命令工具帮忙修复snapshot，重要的snapshot建议多备份。</p><h3 id="更换Master"><a href="#更换Master" class="headerlink" title="更换Master"></a>更换Master</h3><p>如果Master服务器出现问题时，需要替换它。<br>例如，A，B作为Redis服务器运行。A是Master，B是Slave。不幸地，A机器网络出现问题，现在要用C，来作为新的Master，怎么做，</p><ol><li>告诉B，执行Save命令，生成最新的snapshot。</li><li>snapshot完成后，启动C，加载snapshot。</li><li>告诉B，成为C的Slave。</li></ol><p>还有一个可选方法，将B作为Master，C作为B的Slave。</p><p>处理异常，我们还有Redis Sentinel工具，后续再介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章，更多的是Redis使用说明以及Redis提供解决问题的思路，后续需要实战练习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍完Redis的基本命令，来看看Redis对数据存储的方面的设计。&lt;/p&gt;
&lt;h2 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h2&gt;&lt;p&gt;Redis提供两种方式进行持久化，Snapsho
      
    
    </summary>
    
      <category term="Redis" scheme="http://zhangzemiao.com/categories/Redis/"/>
    
    
      <category term="NOSQL" scheme="http://zhangzemiao.com/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用命令</title>
    <link href="http://zhangzemiao.com/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhangzemiao.com/Redis/Redis常用命令/</id>
    <published>2017-02-06T07:43:40.000Z</published>
    <updated>2020-12-17T07:44:38.903Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇，我在电脑上安装了windows版本的redis，使用Jedis编写代码测试。然后。。。停顿了好长时间没有继续学习。</p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>Redis，内存分布式数据库，支持5种数据类型（不确定），提供持久化支持，是近几年火起来的NOSQL。</p><h3 id="数据库比较"><a href="#数据库比较" class="headerlink" title="数据库比较"></a>数据库比较</h3><table><thead><tr><th>数据库</th><th>类型</th><th>数据存储</th><th>查询类型</th><th>额外功能</th></tr></thead><tbody><tr><td>Redis</td><td>内存非关系型</td><td>String，List，Set，Hash，Sorted Set</td><td>CURD，批量处理，部分事务支持</td><td>订阅/取消服务 主从复制</td></tr><tr><td>memcached</td><td>内存非关系型</td><td>mapping key to value</td><td>CURD</td><td>并发集群服务</td></tr><tr><td>mysql</td><td>关系型</td><td>常用数据</td><td>CURD，sp</td><td>ACID，主从结构</td></tr><tr><td>PostgreSQL</td><td>关系型</td><td>常用数据</td><td>CURD，sp</td><td>ACID，主从结构，第三方扩展</td></tr><tr><td>MongoDB</td><td>磁盘非关系型文件存储</td><td>BSON documents</td><td>CURD</td><td>map-redusce，主从，集群</td></tr></tbody></table><h3 id="Redis数据同步"><a href="#Redis数据同步" class="headerlink" title="Redis数据同步"></a>Redis数据同步</h3><p>Redis有两种同步方式，将内存数据备份至磁盘：</p><ul><li>point-in-time dump ， 当一个确切的事情发生（一段时间内，满足一定量的写次数）或者执行dump-to-disk命令</li><li>append-only file，灵活配置，从不同步到每秒同步，以及同步每一个操作。</li></ul><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><p>STRING，LIST，SET，HASH，ZSET。五种数据结构共享命令，DEL，TYPE，RENAME以及其他。<br>STRING，支持字符串，整型，浮点型。整型和浮点型可以自增，自减。<br>LIST，字符串列表。支持push/pop，可以在队头以及队尾操作。<br>SET，未排序的唯一集合。<br>HASH，存储键值对。<br>ZSET，排序列表。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这里有个<a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis中文网站</a>，方便检索Redis知识，以及Command。</p><p>我这里只是列出相关命令用法，简单说明。详细的用例以及相关参数说明，可以去网站中查询。</p><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><ol><li>INCR key-name 自增1</li><li>DECR key-name 自减1</li><li>INCRBY key-name amount 自增提供的值</li><li>DECRBY key-name amount 自减提供的值</li><li>INCRBYFLOAT key-name amount 自增提供的浮点值</li></ol><p>对字符串操作，<br><strong>下标是从0开始的，跟Java语言一样。</strong></p><ol><li>APPEND key-name value 拼接字符串至末尾</li><li>GETRANGE key-name start end  获取子串（包含下标）</li><li>SETRANGE key-name offset value  设置子串，从指定下标开始</li><li>GETBIT key-name offset 将字符串当做二进制字节串，获取偏移位置的值，要么是0，要么是1</li><li>SETBIT key-name offset value 设置指定偏移位置的值</li><li>BITCOUNT key-name [start end] 统计字节串中，有多少个1。可以统计子串。</li><li>BITOP operation dest-key key-name [key-name …] 按位操作，操作有AND，OR，NOT，XOR。结果保存在dest-key</li></ol><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><ol><li>RPUSH key-name value [value …] 在右端存储元素</li><li>LPUSH key-name value [value …] 在左端存储元素</li><li>RPOP key-name 出列右端元素</li><li>LPOP key-name 出列左端元素</li><li>LINDEX key-name offset 获取列表中指定索引的元素（左端）</li><li>LRANGE key-name start end 获取指定索引范围的元素（包含边界）</li><li>LTRIM key-name start end 修剪原始列表，只剩start到end索引</li></ol><p>进阶，</p><ol><li>BLPOP key-name [key-name …] timeout 阻塞出列（左端），当没有元素时，阻塞或者超时等待。</li><li>BRPOP key-name [key-name …] timeout 阻塞出列（右端）</li><li>RPOPLPUSH source-key dest-key 删除source的列表尾部元素，放入dest列表头部。source和dest可以是同一个列表</li><li>BRPOPLPUSH source-key dest-key 阻塞版本</li></ol><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><ol><li>SADD key-name item [item …] 添加元素，返回成功添加的数量</li><li>SREM key-name item [item …] 删除元素，返回成功删除的数量</li><li>SISMEMBER key-name item  判断元素是否在SET中。</li><li>SCARD key-name 获取集合的元素数量</li><li>SMEMBERS key-name 返回SET集合中所有元素</li><li>SRANDMEMBER key-name [count] 随机返回一个或者多个集合中的元素。</li><li>SPOP key-name  随机清除并返回一个元素</li><li>SMOVE source-key dest-key item 如果元素在source集合，清除并添加至dest集合，并返回该元素</li></ol><p>进阶，</p><ol><li>SDIFF key-name [key-name …] 返回第一个集合里的相关元素，这些元素不再其他任何集合里</li><li>SDIFFSTORE dest-key key-name [key-name …] 类似SDIFF，将元素存储在dest-key中</li><li>SINTER key-name [key-name …] 返回所有集合共有的元素</li><li>SINTERSTORE dest-key key-name [key-name …] 将集合共有的元素存储在dest-key中</li><li>SUNION key-name [key-name …] 返回集合合并后的所有元素</li><li>SUNIONSTORE dest-key key-name [key-name …] 将合并后的元素存储在dest-key中</li></ol><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><ol><li>HMGET key-name key [key …] 获取相关key的值</li><li>HMSET key-name key value [key value …]  存储key value。</li><li>HDEL key-name key [key …] 删除相应的key。返回已删除的个数。</li><li>HLEN key-name  返回hash集合的个数。</li></ol><p>进阶，</p><ol><li>HEXISTS key-name key  key是否存在于指定hash集合</li><li>HKEYS key-name  获取hash集合中的所有key</li><li>HVALS key-name 获取hash集合中所有的value</li><li>HGETALL key-name 获取hash集合中所有的key-value组合</li><li>HINCRBY key-name key increment 自增提供key的值（整型增量）。</li><li>HINCRBYFLOAT key-name key increment 自增提供key的值（浮点变量）。</li></ol><h3 id="Sorted-SET"><a href="#Sorted-SET" class="headerlink" title="Sorted SET"></a>Sorted SET</h3><ol><li>ZADD key-name score member [score member …]   有序集合添加分数/成员， 分数相同，有序的字典顺序。</li><li>ZREM key-name member [member]  有序集合删除相关成员。</li><li>ZCARD key-name 返回有序集合成员的个数</li><li>ZINCRBY key-name increment member  为有序集合的指定成员的score加上增量increment。</li><li>ZCOUNT key-name min max 返回有序集合中成员的分数在最小和最大之间的数量。</li><li>ZRANK  key-name member 返回指定成员的在集合中的位置（索引）。按照从小到大排列</li><li>ZSCORE key-name member 返回指定成员的分数。</li><li>ZRANGE key-name start stop [ WITHSCORES]  返回指定索引范围的成员（可附带分数）</li></ol><p>进阶，</p><ol><li>ZREVRANK key-name member  返回成员在有序集合的位置，与ZRANK的排序是相反的。从大到小排列。</li><li>ZREVRANGE key-name start stop [WITHSCORES]  与ZRANGE的排序相反。返回指定索引范围内的成员，但是排序是从大到小。</li><li>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]  分数在最小和最大之间，由低到高排序，是否返回score，limit是否分页，offset返回结果起始位置，count返回结果数量</li><li>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]  分数在最大和最小之间，由高到低排序</li><li>ZREMRANGEBYRANK key-name start stop 删除指定索引范围的成员</li><li>ZREMRANGEBYSCORE key-name min max 删除指定分数范围内的成员</li><li>ZINTERSTORE dest-key key-count key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM| MIN| MAX] 将给定的有序集合的交集放到dest集合中。weights是给原来集合中的成员的score乘积因子，默认为1。 AGGREGATE 成员的分数聚合方式，默认是SUM。</li><li>ZUNIONSTORE dest-key key-count key [key …] [WEIGHTS weight [weight…]] [AGGREGATE SUM| MIN| MAX]  将给定的有序集合的并集放到dest集合中。</li></ol><h3 id="publish-subscribe"><a href="#publish-subscribe" class="headerlink" title="publish/subscribe"></a>publish/subscribe</h3><ol><li>SUBSCRIBE channel [channel …]  订阅频道</li><li>UNSUBSCRIBE [channel]  取消订阅指定的或者所有的</li><li>PUBLISH  channel message 发布消息到指定的频道</li><li>PSUBSCRIBE pattern [pattern …]  订阅给定的模式</li><li>PUNSUBSCRIBE [pattern …] 取消特定的模式的消息</li></ol><p>消息订阅/取消模式，有两个问题。</p><ul><li>Redis系统的可靠性。早前版本中，客户已经订阅了拼单，但是读消息的速度不够快，导致Redis会积压大量缓存。当足够大时，Redis会崩溃。新版本，不会有这问题，可以设置buffer size。</li><li>二是数据传输可靠性，如果客户订阅频道，但是连接出问题。再重连上来之前，如果有发布消息，那么重连的客户不会收到，导致信息流失。</li></ul><p>需要寻求更好的解决方案，待定。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>Sort排序命令，参数比较长，不列出来了。</p><p>事务处理相关命令，WATCH，MULTI，EXEC，UNWATCH，DISCARD<br>批量执行， MULTI+多条命令+EXEC</p><p>KEY过期处理，</p><ol><li>PERSIST key-name  清除期限时间</li><li>TTL key-name  返回到过期的时间长度</li><li>EXPIRE key-name seconds 设置过期的时间</li><li>EXPIREAT key-name timestamp 设置过期的Unix时间戳</li><li>PTTL key-name 返回到过期时间的毫秒数</li><li>PEXPIRE key-name milliseconds 设置过期的毫秒数</li><li>PEXPIREAT key-name timestamp-milliseconds 设置到过期时间的Unix时间戳，以毫秒为单位。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里包含的大部分的命令，方便查找，温故知新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇，我在电脑上安装了windows版本的redis，使用Jedis编写代码测试。然后。。。停顿了好长时间没有继续学习。&lt;/p&gt;
&lt;h2 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初识&quot;&gt;&lt;/a&gt;初识&lt;/h2&gt;&lt;p&gt;R
      
    
    </summary>
    
      <category term="Redis" scheme="http://zhangzemiao.com/categories/Redis/"/>
    
    
      <category term="NOSQL" scheme="http://zhangzemiao.com/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架使用与分析五</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90%E4%BA%94/"/>
    <id>http://zhangzemiao.com/Java并发编程/Executor框架使用与分析五/</id>
    <published>2017-01-22T09:11:58.000Z</published>
    <updated>2020-12-17T07:44:38.898Z</updated>
    
    <content type="html"><![CDATA[<p>继续介绍Executor框架，第五篇。</p><p><a href="/Java并发编程/Executor框架使用与分析一">第一篇</a>介绍newCachedThreadPool<br><a href="/Java并发编程/Executor框架使用与分析二">第二篇</a>介绍newFixedThreadPool<br><a href="/Java并发编程/Executor框架使用与分析三">第三篇</a>介绍newFixedThreadPool以及Future接口<br><a href="/Java并发编程/Executor框架使用与分析四">第四篇</a>介绍ScheduledThreadPoolExecutor执行延时任务</p><p>这篇介绍以及分析使用ScheduledThreadPoolExecutor执行周期性任务。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>执行周期性任务，先看样例</p><p>一个简单的Runnable任务类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RunnableTask</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"%s: Starting at : %s\n"</span>,name,<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(<span class="string">"Hello, world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService executor=Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    System.out.printf(<span class="string">"Main: Starting at: %s\n"</span>,<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    RunnableTask task=<span class="keyword">new</span> RunnableTask(<span class="string">"Task"</span>);</span><br><span class="line">    ScheduledFuture&lt;?&gt; result= executor.scheduleAtFixedRate(task, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Main: Delay: %d\n"</span>, result.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">        <span class="comment">// Sleep the thread during 500 milliseconds.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Main: Delay: %d\n"</span>, result.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.printf(<span class="string">"Main: Finished at: %s\n"</span>,<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>可以看出，测试代码跟第四篇文章，是类似的。在执行任务时，所用的接口不一样。但是，都使用的是ScheduledExecutorService接口所提供的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//这篇文章要分析的方法</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><h3 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行Runnable任务"><a href="#执行Runnable任务" class="headerlink" title="执行Runnable任务"></a>执行Runnable任务</h3><p>Executors内部使用的是ScheduledThreadPoolExecutor，对外接口是ScheduledExecutorService。</p><p>ScheduledThreadPoolExecutor.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      <span class="comment">//延时时间，转换成Nanos</span></span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      <span class="comment">//周期性时间</span></span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>不支持null 任务，抛空指针异常</strong><br><strong>不支持周期性时间为负，抛非法参数异常</strong><br>将Runnable任务封装成ScheduledFutureTask，跟第四篇分析延时任务一样。</p><p>delayedExecute方法，不再分析，可以看第四篇分析文章。周期性任务与延时任务的差别在于，多了一个period时间，本身Executor框架的执行逻辑是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用的是DelayedWorkQueue，添加任务不阻塞。Worker线程运行起来后，会轮询从队列中获取任务来执行。这里的逻辑依旧沿用ThreadPoolExecutor的逻辑，是一样的。区别在于任务本身的不同。这里的任务是前面提及的ScheduledFutureTask，由于是周期性任务，那么run方法的执行，跟延时任务是不同的，调用runAndReset方法，那么执行成功，会设置更新下一次的运行时间，以及重新添加task至队列。意味着在执行构成中，又添加了一个task。那么worker线程会一直执行下去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里是true</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureTask.java，这里运行正常返回true，如果运行过程中，遇到异常，返回false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.call(); <span class="comment">// don't set result</span></span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ScheduledThreadPoolExecutor.ScheduledFutureTask，更新一下task的time时间，也就是延时的时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ScheduledThreadPoolExecutor.java，将更新后的任务再次添加至队列中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关闭Executor"><a href="#关闭Executor" class="headerlink" title="关闭Executor"></a>关闭Executor</h3><p>如果你想要任务一直运行下去，就不需要关闭Executor。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在运行周期性任务（最原始的任务，样例中就是RunnableTask）时，如果任务抛出异常，那么会影响后续的执行（周期性任务不会执行了），但是Executor不会因为异常关闭。<br>对于ScheduledThreadPoolExecutor，我们还有一个接口，没有分析，跟本次分析的区别，在于构造ScheduledFutureTask的不同，以及run方法中执行的细节区别。嗯，不再举个栗子分析了。其实就是setNextRunTime方法中的差别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续介绍Executor框架，第五篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/Java并发编程/Executor框架使用与分析一&quot;&gt;第一篇&lt;/a&gt;介绍newCachedThreadPool&lt;br&gt;&lt;a href=&quot;/Java并发编程/Executor框架使用与分析二&quot;&gt;第二篇&lt;
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架使用与分析四</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90%E5%9B%9B/"/>
    <id>http://zhangzemiao.com/Java并发编程/Executor框架使用与分析四/</id>
    <published>2017-01-12T06:20:51.000Z</published>
    <updated>2020-12-17T07:44:38.899Z</updated>
    
    <content type="html"><![CDATA[<p>继续介绍Executor框架，第四篇。</p><p><a href="/Java并发编程/Executor框架使用与分析一">第一篇</a>介绍newCachedThreadPool<br><a href="/Java并发编程/Executor框架使用与分析二">第二篇</a>介绍newFixedThreadPool<br><a href="/Java并发编程/Executor框架使用与分析三">第三篇</a>介绍newFixedThreadPool以及Future接口</p><p>这篇开始介绍ScheduledThreadPoolExecutor。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>有时候我们想延时执行一些任务，看样例。</p><p>一个简单的继承Callable接口的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"%s: Starting at : %s\n"</span>,name,<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用Scheduled</span></span><br><span class="line">    ScheduledThreadPoolExecutor executor=(ScheduledThreadPoolExecutor)</span><br><span class="line">            Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    System.out.printf(<span class="string">"Main: Starting at: %s\n"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        CallableTask task = <span class="keyword">new</span> CallableTask(<span class="string">"Task "</span> + i);</span><br><span class="line">        <span class="comment">//schedule方法</span></span><br><span class="line">        executor.schedule(task, i + <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">"Main: Ends at: %s\n"</span>,<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>本身例子很简单，使用SchedudThreadPoolExecutor执行一些延时任务，透过表面看本质，看看背后的实现和设计。</p><h3 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建Executor</h3><p>Executors.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ScheduledThreadPoolExecutor.java<br>只有一个参数设置corePoolSize。<br><strong>这里，阻塞队列使用的是DelayedWorkQueue。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="执行Callable任务"><a href="#执行Callable任务" class="headerlink" title="执行Callable任务"></a>执行Callable任务</h3><p>这里是schedule方法的源码，triggerTime方法，记录执行任务的时间点。<br>ScheduledFutureTask继承于FutureTask（在上一篇中，分析了FutureTask背后的原理，可以回头看看），包装任务和任务执行的时间点，在ScheduledFutureTask构造函数中，还有一个sequencer，记录序列号，具体什么用，往下看。<br>最外层还是一个decorateTask方法，再进行包装，代码有点怪怪的。。。可继承，应该是关键，<br>最后执行delayedExecute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</span><br><span class="line">                                   triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() +</span><br><span class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点分析delayedExecute方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果是关闭状态，拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//这里是DelayedWorkQueue，非阻塞添加</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">//再次检查是否关闭executor，以及判断是非周期性任务，且清除任务成功，则取消任务</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//正常运行状态，执行该路径</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Worker线程，并启动Worker线程，最后又回到runWorker方法，之前分析过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的task是封装过后的ScheduledFutureTask。</strong><br>在runWorker方法中，worker线程阻塞从队列拿去元素（即ScheduledFutureTask），然后执行run方法。这里使用DelayedWorkQueue，<br>简单分一下DelayedWorkQueue的take方法，也就是worker线程的阻塞的方法，</p><p>ScheduledThreadPoolExecutor.DelayedWorkQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//拿第一个元素</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//队列为空，worker线程阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取任务执行，还需要delay的时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">//如果小于等于0，则返回给worker线程</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">//初始状态，leader是为null的，先过</span></span><br><span class="line">                <span class="comment">//再看，多个Worker线程对于leader是竞争关系，当有其他worker设置leader线程时，阻塞当前worker线程</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里赋值给leader线程，让worker线程超时等待所需等待的时间</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//最后leader赋值为null</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//最后返回后，如果队列不为空，则唤醒阻塞的worker线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ScheduledThreadPoolExecutor.ScheduledFutureTask<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承FutureTask，并重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//是否为周期性任务，这里是false</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">//这里的代码不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//执行父类的run方法，即FutureTask的run方法，调用最初的Callable接口的任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，对于ScheduledThreadPoolExecutor怎么执行延时任务，已基本清除。在ThreadPoolExecutor基础上，继承FutureTask，增加周期性和延时运行的属性。再结合DelayedWorkQueue，获取ScheduledFutureTask任务，最终回到FutureTask，调用原始的被封装的任务。</p><p>这里有个小细节，在ScheduledFutureTask的run方法中，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个方法决定是否取消任务，对于延时任务，periodic是<span class="keyword">false</span>。是否取消，由executeExistingDelayedTasksAfterShutdown来决定，默认是ture。意味着，即使我们调用了shutdown方法，是允许任务继续执行的。如果你不想，可以将executeExistingDelayedTasksAfterShutdown设置成<span class="keyword">false</span>。</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRunInCurrentRunState</span><span class="params">(<span class="keyword">boolean</span> periodic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ?</span><br><span class="line">   continueExistingPeriodicTasksAfterShutdown :</span><br><span class="line">    executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关闭Executor"><a href="#关闭Executor" class="headerlink" title="关闭Executor"></a>关闭Executor</h3><p>沿用ThreadPoolExecutor的shutdown逻辑，不再分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析源码后，弄清楚ScheduledThreadPoolExecutor怎么支持延时任务，后续再分析支持周期性任务，就容易多了。<br><strong>延时任务，延时是相对于添加任务的时间点。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续介绍Executor框架，第四篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/Java并发编程/Executor框架使用与分析一&quot;&gt;第一篇&lt;/a&gt;介绍newCachedThreadPool&lt;br&gt;&lt;a href=&quot;/Java并发编程/Executor框架使用与分析二&quot;&gt;第二篇&lt;
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架使用与分析三</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90%E4%B8%89/"/>
    <id>http://zhangzemiao.com/Java并发编程/Executor框架使用与分析三/</id>
    <published>2017-01-10T08:08:50.000Z</published>
    <updated>2020-12-17T07:44:38.898Z</updated>
    
    <content type="html"><![CDATA[<p>继续介绍Executor框架，第三篇。</p><p><a href="/Java并发编程/Executor框架使用与分析一">第一篇</a>介绍newCachedThreadPool<br><a href="/Java并发编程/Executor框架使用与分析二">第二篇</a>介绍newFixedThreadPool</p><p>前两篇文章中，Executor执行的任务（Runnable接口），没有返回结果。这么会用到Future接口和Callable接口。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future接口，子类有FutureTask，ForkJoinTask的子类，以及1.8中新加的CompletableFuture。<br>顾名思义，Future表示一种未来的结果，在调用executor方法时，返回Future接口，此时的结果可能并未准备好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>阶乘运算</p><p>FactorialCalculator.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Callable接口，阶乘计算类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialCalculator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FactorialCalculator</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((number == <span class="number">0</span>) || (number == <span class="number">1</span>)) &#123;</span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"%s: %d\n"</span>,Thread.currentThread().getName(),result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建Executor</span></span><br><span class="line">ThreadPoolExecutor executor = (ThreadPoolExecutor)</span><br><span class="line">Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">List&lt;Future&lt;Integer&gt;&gt; resultList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Random random=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">      Integer number= random.nextInt(<span class="number">10</span>);</span><br><span class="line">      FactorialCalculator calculator=<span class="keyword">new</span> FactorialCalculator(number);</span><br><span class="line">              <span class="comment">//executor提交Callable任务，并返回Future接口的结果</span></span><br><span class="line">      Future&lt;Integer&gt; result=executor.submit(calculator);</span><br><span class="line">      resultList.add(result);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//等待Future的结果准备好</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"Main: Number of Completed Tasks: %d\n"</span>,executor.getCompletedTaskCount());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resultList.size(); i++) &#123;</span><br><span class="line">Future&lt;Integer&gt; result = resultList.get(i);</span><br><span class="line">System.out.printf(<span class="string">"Main: Task %d: %s\n"</span>, i, result.isDone());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (executor.getCompletedTaskCount() &lt; resultList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">System.out.printf(<span class="string">"Main: Results\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;resultList.size(); i++) &#123;</span><br><span class="line">      Future&lt;Integer&gt; result=resultList.get(i);</span><br><span class="line">      Integer number=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        number=result.get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.printf(<span class="string">"Main: Task %d: %d\n"</span>,i,number);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建Executor</h3><p>这部分，可以看第二篇分析文章，使用的就是newFixedThreadPool</p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>这里，与之前分析的不一样。这里提交的任务是Callable接口。<br><strong>不接受 null 任务，抛空指针异常</strong></p><p>AbstractExecutorService.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//将Callable接口转成RunnableFuture接口了，该接口即使Runnable，也是Future</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，最终运行的task是FutureTask，而Executor把它当做Runnable接口来运行。来看看FutureTask做了些什么。<br>FutureTask.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数，初始状态为NEW</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">//执行Callable接口，两种情况，要么异常，要么有结果</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果Callable任务正常执行，那么调用set(Result)方法，设置本身的状态，保存计算结果，再调用finishCompletion()方法收尾，换新等待线程，并调用done()方法(这是个钩子方法，FutureTask是个空方法)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果Callable任务执行抛出异常，那么调用setException(ex)方法，设置最终状态，输出对象是异常对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据FutureTask本身的状态，看看get方法的返回，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//一直等</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据状态，返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">//正常，返回计算结果</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line"><span class="comment">//取消或者中断，则抛出取消异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line"><span class="comment">//都不是，则是执行中遇到的异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Executor运行的，跟第二篇是一样的，不再重复。这里Callable的任务执行，由FutureTask来包装，支持Future功能。</p><h3 id="关闭Executor"><a href="#关闭Executor" class="headerlink" title="关闭Executor"></a>关闭Executor</h3><p>设置SHUTDOWN状态，中断所有Worker线程，返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Executor，有结果和没有结果的任务，都分析了。后续看看支持调度的Executor以及1.8新加的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续介绍Executor框架，第三篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/Java并发编程/Executor框架使用与分析一&quot;&gt;第一篇&lt;/a&gt;介绍newCachedThreadPool&lt;br&gt;&lt;a href=&quot;/Java并发编程/Executor框架使用与分析二&quot;&gt;第二篇&lt;
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>builder设计模式使用与分析</title>
    <link href="http://zhangzemiao.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/builder%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://zhangzemiao.com/设计模式/builder设计模式使用与分析/</id>
    <published>2017-01-06T07:52:19.000Z</published>
    <updated>2020-12-17T07:44:38.906Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中，一直使用到builder模式，记录一下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>这个builder设计模式好像不属于四人帮提的23种，但不妨碍它的套路。builder，我的理解是构建。构建什么？构建Model。什么是Model?可以是简单的POJO，也可以是包含复杂业务的Business Model。我这里涉及的是POJO。</p><p>使用builder模式，保证Model的不可变性，避免其他地方恶意修改。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="Web请求参数多变"><a href="#Web请求参数多变" class="headerlink" title="Web请求参数多变"></a>Web请求参数多变</h3><p>这里我自己的经验，是在web服务中，一个请求拥有太多参数（比如超过5个），而且随着业务的精进，可能还会扩展更多的参数，那么可以考虑builder模式，封装变化。</p><h3 id="Web-Service服务请求体包装"><a href="#Web-Service服务请求体包装" class="headerlink" title="Web Service服务请求体包装"></a>Web Service服务请求体包装</h3><p>在系统中，需要经常调用数据服务，传统的SOAP服务，亦或RestFull服务。通常需要提供request body。如果request的处于变化之中，想要便于扩展，可以考虑builder模式。也可以跳出这个思路，Web Service做版本控制。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>这里有个需求，提供一个Http Get服务，根据提供的参数生成PDF文档。这里参数可能随便支持的业务而扩展。对于生成PDF的http服务背后，对应的是Service接口，那么直接将Http请求的参数，作为Service接口的形参，是不友好的。可以创建一个PDFRequest，封装请求参数的变化，扩展时，只要更新PDFRequest的builder类。对于Service接，适配PDFRequest，这样就屏蔽的变化。</p><ul><li>Model构造函数私有</li><li>只提供Get方法</li><li>静态内部Builder类</li><li>内部类build方法创建Model</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数私有</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PDFRequest</span><span class="params">(PDFRequestBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.xxx = builder.xxx;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFRequestBuilder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> xxx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PDFRequestBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PDFRequestBuilder <span class="title">xxx</span><span class="params">(String xxx)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.xxx = xxx;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只提供Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getxxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近工作中，一直使用到builder模式，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;这个builder设计模式好像不属于四人帮提的23种，但不妨碍它的套路。
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zhangzemiao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架使用与分析二</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90%E4%BA%8C/"/>
    <id>http://zhangzemiao.com/Java并发编程/Executor框架使用与分析二/</id>
    <published>2016-12-29T08:09:52.000Z</published>
    <updated>2020-12-17T07:44:38.898Z</updated>
    
    <content type="html"><![CDATA[<p>继续介绍Executor框架，这是第二篇。</p><p>在<a href="/Java并发编程/Executor框架使用与分析一">第一篇</a>的基础上，修改Server类的构造函数，使用newFixedThreadPool创建Executor。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();</span></span><br><span class="line">executor = (ThreadPoolExecutor)Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建ThreadPool"><a href="#创建ThreadPool" class="headerlink" title="创建ThreadPool"></a>创建ThreadPool</h2><p>Executors.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这里，coreSize和maxSize都是设定的值，然后阻塞队列使用的LinkedBlockingQueue，跟newCachedThreadPool使用SyschronousQueue，不一样。</strong></p><p>ThreadPoolExecutor.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><p>代码路径跟上一篇分析是一样的。执行execute方法，添加任务，当前的worker count小于corePoolSize（这里的例子为5），调用addWorker方法。ctl自增一，创建Worker并启动。当worker count不小于corePoolSize时，则调用阻塞队列的offer方法，添加任务。<br><strong>execute方法不接受 null 任务，抛空指针异常</strong></p><p>Worker运行分析，Worker本身就是一个线程，启动后，调用ThreadPoolExecutor的runWorker方法，先执行firstTask，然后从队列拿任务，这里会一直阻塞（支持中断）获取task。返回task后，执行。如果返回task为null，那么启动worker退出机制，自减以及从workers中清除。</p><h2 id="关闭Executor"><a href="#关闭Executor" class="headerlink" title="关闭Executor"></a>关闭Executor</h2><p>设置成SHUTDOWN状态，中断阻塞的worker（等待获取任务的线程），执行完正在进行的任务，worker线程正常退出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续介绍Executor框架，这是第二篇。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;/Java并发编程/Executor框架使用与分析一&quot;&gt;第一篇&lt;/a&gt;的基础上，修改Server类的构造函数，使用newFixedThreadPool创建Executor。&lt;br&gt;&lt;figure 
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架使用与分析一</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://zhangzemiao.com/Java并发编程/Executor框架使用与分析一/</id>
    <published>2016-12-20T06:44:46.000Z</published>
    <updated>2020-12-17T07:44:38.897Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Executor框架。</p><h2 id="基本框架介绍"><a href="#基本框架介绍" class="headerlink" title="基本框架介绍"></a>基本框架介绍</h2><p>顶层接口Executor，ExecutorService继承Executor，AbstractExecutorService继承ExecutorService，ThreadPoolExecutor继承抽象ExecutorService。还有ScheduledThreadPoolExecutor。<br>Java API还提供的工具类Executors，帮我们创建不同的Executor实现类，针对不同的应用场景。</p><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>newCachedThreadPool</li><li>newScheduledThreadPool</li><li>newWorkStealingPool（1.8新加的）</li></ul><p>我们将分析这几种情况，以及相关源码分析。</p><p><img src="http://photos.zhangzemiao.com/blog_executor.jpg" alt></p><p>Executor<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Date initDate;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">initDate = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"%s: Task %s: Created on: %s\n"</span>, Thread.currentThread().getName(), name, initDate);</span><br><span class="line">System.out.printf(<span class="string">"%s: Task %s: Started on: %s\n"</span>, Thread.currentThread().getName(), name, <span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Long duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">System.out.printf(<span class="string">"%s: Task %s: Doing a task during %d seconds\n"</span>, Thread.currentThread().getName(), name,</span><br><span class="line">duration);</span><br><span class="line">TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"%s: Task %s: Finished on: %s\n"</span>, Thread.currentThread().getName(), name, <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">    System.out.printf(<span class="string">"Server: A new task has arrived\n"</span>);</span><br><span class="line">    executor.execute(task);</span><br><span class="line">    System.out.printf(<span class="string">"Server: Pool Size: %d\n"</span>,executor.getPoolSize());</span><br><span class="line">    System.out.printf(<span class="string">"Server: Active Count: %d\n"</span>,executor.getActiveCount());</span><br><span class="line">    System.out.printf(<span class="string">"Server: Completed Tasks: %d\n"</span>,executor.getCompletedTaskCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Executors创建cached thread pool</span></span><br><span class="line">Server server = <span class="keyword">new</span> Server();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">server.executeTask(task);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//关闭server</span></span><br><span class="line">server.endServer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>根据源码，代码分为三步，</p><ul><li>initial</li><li>executeTask</li><li>shutDown</li></ul><h3 id="创建ThreadPool"><a href="#创建ThreadPool" class="headerlink" title="创建ThreadPool"></a>创建ThreadPool</h3><p>这里使用的是CachedThreadPool，corePoolSize为0，max size为Integer最大值。线程存好时间是60秒。队列使用SynchronousQueue。<br>Executors.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadPoolExecutor.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认线程工厂，handler</span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>ThreadPoolExecutor.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//这里，计算worker count，初始状态是0，但是corePoolSize也是为0，不执行里面代码</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始状态isRunning返回true, offer返回false,对于该样例，不会这里的代码</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Worker，并启动Worker</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里使用了goto</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//workQueue.isEmpty永远返回true</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//这里wc初始值为0</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//CAS ctl自增1，成功后跳出goto，失败后retry</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Worker</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建成功后，执行Worker这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进入Worker执行流程，<br>ThreadPoolExecutor.Worker<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里回调ThreadPoolExecutor中的runWorker方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">//firstTask就是要执行的任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里定义了一些模板方法，是空的，方便继承ThreadPoolExecutor时，重写</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行，这里要注意，是直接调用run方法，而不是当做线程来执行</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//执行完后的处理</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看如果worker执行完后的处理，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line"><span class="comment">//正常情况是false，不执行</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line"><span class="comment">//这里ctl自减1，直到成功</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//记录完成的任务的个数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//这里清除掉worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line"><span class="comment">//这里min等于0，</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line"><span class="comment">//workQueue一直返回true</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//执行这里的代码</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，CachedThreadPool的执行过程，分析了一篇，来一个task，就启动一个Worker来执行。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>shutdown方法不会阻止已经运行的任务，但是也不接受新的任务了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置成shutdown状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//中断worker线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是第一篇分析Executor框架，目前只简单涉及CachedThreadPool的使用。嗯，看看SynchronousQueue这个队列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍Executor框架。&lt;/p&gt;
&lt;h2 id=&quot;基本框架介绍&quot;&gt;&lt;a href=&quot;#基本框架介绍&quot; class=&quot;headerlink&quot; title=&quot;基本框架介绍&quot;&gt;&lt;/a&gt;基本框架介绍&lt;/h2&gt;&lt;p&gt;顶层接口Executor，ExecutorService继承Exe
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier使用与分析</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CyclicBarrier%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://zhangzemiao.com/Java并发编程/CyclicBarrier使用与分析/</id>
    <published>2016-12-19T02:34:47.000Z</published>
    <updated>2020-12-17T07:44:38.897Z</updated>
    
    <content type="html"><![CDATA[<p>介绍CyclicBarrier使用，以及分析实现原理。</p><h2 id="API描述"><a href="#API描述" class="headerlink" title="API描述"></a>API描述</h2><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="noopener">Java 1.8的API</a>描述，允许一批线程到达一个共同屏障点（common barrier point）。在涉及需要线程需要相互等待的场景，可以考虑CyclicBarrier。屏障机制可以重复使用。</p><p>await()/ await(long timeout, TimeUnit unit)，线程等待，等待所有的线程都调用await方法。<br>getNumberWaiting()，返回当前已经等待的线程个数。<br>getParties()，返回需要的等待的线程个数，是构造函数的初始值，不会变。<br>isBroken()，是否为broken状态。<br>reset()，重置。</p><p>Barrier屏障，可能不好理解。可以理解设置一道关卡，先来的不能过，需要等“大家”都到了，才能一起过。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>矩阵中查找特定元素，这里都为int。</p><h3 id="矩阵模拟"><a href="#矩阵模拟" class="headerlink" title="矩阵模拟"></a>矩阵模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixMock</span> </span>&#123;</span><br><span class="line"><span class="comment">//二维数组，模拟矩阵</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> data[][];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MatrixMock</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> length, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    data=<span class="keyword">new</span> <span class="keyword">int</span>[size][length];</span><br><span class="line">    Random random=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">data[i][j] = random.nextInt(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (data[i][j] == number) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印输出有多少个查找元素</span></span><br><span class="line">System.out.printf(<span class="string">"Mock: There are %d ocurrences of number in generated data.\n"</span>,counter,number); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getRow(<span class="keyword">int</span> row) &#123;</span><br><span class="line"><span class="keyword">if</span> ((row &gt;= <span class="number">0</span>) &amp;&amp; (row &lt; data.length)) &#123;</span><br><span class="line"><span class="keyword">return</span> data[row];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行结果"><a href="#行结果" class="headerlink" title="行结果"></a>行结果</h3><p>存储每行的查找数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="comment">//存储每行的查找个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> data[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Results</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">data[position] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getData() &#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="屏障执行任务"><a href="#屏障执行任务" class="headerlink" title="屏障执行任务"></a>屏障执行任务</h3><p>当屏障抵达后，执行的任务，合并行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grouper</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Results results;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Grouper</span><span class="params">(Results results)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.results = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> finalResult=<span class="number">0</span>;</span><br><span class="line">    System.out.printf(<span class="string">"Grouper: Processing results...\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> data[]=results.getData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number:data)&#123;</span><br><span class="line">      finalResult+=number;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">"Grouper: Total result: %d.\n"</span>,finalResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程任务"><a href="#线程任务" class="headerlink" title="线程任务"></a>线程任务</h3><p>5个线程任务，每个线程任务查找2000行，执行的run方法最后调用await方法，等待其他线程执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> firstRow;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lastRow;</span><br><span class="line"><span class="keyword">private</span> MatrixMock mock;</span><br><span class="line"><span class="keyword">private</span> Results results;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Searcher</span><span class="params">(<span class="keyword">int</span> firstRow, <span class="keyword">int</span> lastRow, MatrixMock mock, Results results, <span class="keyword">int</span> number, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.firstRow = firstRow;</span><br><span class="line"><span class="keyword">this</span>.lastRow = lastRow;</span><br><span class="line"><span class="keyword">this</span>.mock = mock;</span><br><span class="line"><span class="keyword">this</span>.results = results;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line"><span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line">System.out.printf(<span class="string">"%s: Processing lines from %d to %d.\n"</span>, Thread.currentThread().getName(), firstRow, lastRow);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = firstRow; i &lt; lastRow; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> row[] = mock.getRow(i);</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (row[j] == number) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">results.setData(i, counter);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"%s: Lines processed.\n"</span>, Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行await方法</span></span><br><span class="line">barrier.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> ROWS=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NUMBERS=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> SEARCH=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PARTICIPANTS=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> LINES_PARTICIPANT=<span class="number">2000</span>;</span><br><span class="line">    </span><br><span class="line">    MatrixMock mock=<span class="keyword">new</span> MatrixMock(ROWS,NUMBERS,SEARCH);</span><br><span class="line">    Results results=<span class="keyword">new</span> Results(ROWS);</span><br><span class="line">    Grouper grouper=<span class="keyword">new</span> Grouper(results);</span><br><span class="line">    CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(PARTICIPANTS,grouper);</span><br><span class="line">    Searcher searchers[]=<span class="keyword">new</span> Searcher[PARTICIPANTS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;PARTICIPANTS; i++)&#123;</span><br><span class="line">      searchers[i]=<span class="keyword">new</span> Searcher(i*LINES_PARTICIPANT, (i*LINES_PARTICIPANT)+LINES_PARTICIPANT, mock, results, <span class="number">5</span>,barrier);</span><br><span class="line">      Thread thread=<span class="keyword">new</span> Thread(searchers[i]);</span><br><span class="line">      thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">"Main: The main thread has finished.\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理机制"><a href="#原理机制" class="headerlink" title="原理机制"></a>原理机制</h2><p>没有直接是AQS，而是使用ReentrantLock以及Condition实现同步机制。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>很简单，没什么可说的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程调用await方法"><a href="#线程调用await方法" class="headerlink" title="线程调用await方法"></a>线程调用await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//await方法的主要逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line"><span class="comment">//使用ReentrantLock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//线程进来锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">//如果broken，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">//线程中断，抛异常，唤醒Condition的等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//count自减</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//如果自减至0，执行BarrierAction</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//非超时等待，直接调用condition的await方法，阻塞当前线程并释放锁</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line"><span class="comment">//超时等待并释放锁</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line"><span class="comment">//中断异常，调用打破屏障方法，是为了唤醒阻塞线程，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//屏障被打破，线程从await方法返回，但是抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">//正常情况（Generation被重置），被唤醒后，返回index</span></span><br><span class="line">            <span class="comment">//什么情况下，Generation被重置? 1.BarrierAction执行 2.调用reset方法</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//最后释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打破当前Barrier，唤醒所有阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置Generation</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结以及使用场景"><a href="#总结以及使用场景" class="headerlink" title="总结以及使用场景"></a>总结以及使用场景</h2><p>CyclicBarrier提供的API方法很少，它与CountDownLatch类有相似之处。Cyclic表示它可以重复设置屏障，但是CountDownLatch不行。<br>从举例来看，CountDownLatch，是模拟举行会议。会议启动（Thread.start），但是阻塞了(CountDownLatch.await)，等待所有参数者参加（CountDownLatch.arrive），会议正是开始（唤醒线程）。<br>CyclicBarrier，模拟矩阵，5个线程(参与者)查找每行的关键字(Thread)，保存行结果（Thread Result）。但是想要最终的结果（final result），需要等待所有线程都跑完，最终执行合并结果(BarrierAction)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍CyclicBarrier使用，以及分析实现原理。&lt;/p&gt;
&lt;h2 id=&quot;API描述&quot;&gt;&lt;a href=&quot;#API描述&quot; class=&quot;headerlink&quot; title=&quot;API描述&quot;&gt;&lt;/a&gt;API描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://docs.or
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch使用与分析</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CountDownLatch%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://zhangzemiao.com/Java并发编程/CountDownLatch使用与分析/</id>
    <published>2016-12-15T06:01:44.000Z</published>
    <updated>2020-12-17T07:44:38.896Z</updated>
    
    <content type="html"><![CDATA[<p>介绍CountDownLatch，并发流程控制。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>看看<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener">Java 1.8的API</a>是怎么说的，一种同步机制，允许一个或者线程等待，直到其他线程执行一些操作完成。CountDownLatch基于一个given count，进行初始化，然后调用await方法，阻塞当前线程的流程。直到其他线程执行countDown方法，直至count变为0。那么阻塞线程被唤醒执行。<br><strong>CountDownLatch中的count不能被重置</strong></p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>模拟开会，组织一个会议，要求10人到齐就开始。会议先准备好，然后参加会议的人员一个个来报到，直至到齐。会议则正式开始。</p><h3 id="VideoConference"><a href="#VideoConference" class="headerlink" title="VideoConference"></a>VideoConference</h3><p>会议类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoConference</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initial count，不能被重置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VideoConference</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">controller = <span class="keyword">new</span> CountDownLatch(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//人员报到，调用countDown</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"%s has arrived."</span>,name);</span><br><span class="line">controller.countDown();</span><br><span class="line">System.out.printf(<span class="string">"VideoConference: Waiting for %d participants.\n"</span>,controller.getCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"VideoConference: Initialization: %d participants.\n"</span>, controller.getCount());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动会议，并等待人员报到</span></span><br><span class="line">            <span class="comment">//API还提供超时等待，如果规定时间内，参与人员没有满员到齐，可做其他处理</span></span><br><span class="line">controller.await();</span><br><span class="line">System.out.printf(<span class="string">"VideoConference: All the participants have come\n"</span>);</span><br><span class="line">System.out.printf(<span class="string">"VideoConference: Let's start...\n"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> VideoConference conference;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Participant</span><span class="params">(VideoConference conference, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.conference = conference;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参加会议，调用arrive方法，报到</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> duration=(<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    conference.arrive(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">VideoConference conference=<span class="keyword">new</span> VideoConference(<span class="number">10</span>);</span><br><span class="line">Thread threadConference=<span class="keyword">new</span> Thread(conference);</span><br><span class="line">    threadConference.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">Participant p = <span class="keyword">new</span> Participant(conference, <span class="string">"Participant "</span> + i);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(p);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>代码很简洁，跟之前解析锁的实现一样，使用AQS实现，内部类Sync实现AQS。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当创建一个CountDownLatch时，initial count设置成AQS的state。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类Sync的方法</span></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><p>CountDownLatch.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//获取共享锁</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractQueuedSynchronizer.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是个模板方法，回调具体的实现，即Sync的实现方法tryAcquireShared()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//如果为负数，调用doXX方法，支持中断的阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CountDownLatch.Sync.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的逻辑很简单，获取state，如果不为0，则返回负数</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="countDown方法"><a href="#countDown方法" class="headerlink" title="countDown方法"></a>countDown方法</h3><p>CountDownLatch.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用AQS的释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractQueuedSynchronizer.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    <span class="comment">//如果return true，则要唤醒阻塞的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回调tryReleaseShared方法<br>CountDownLatch.Sync.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将state自减</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//注意，如果next state是0,即state状态减至0后，return true</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CountDownLatch完全依赖AQS来实现，Doug Lea很牛X。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍CountDownLatch，并发流程控制。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;看看&lt;a href=&quot;http://docs.oracle.com/java
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fork/Join框架使用与分析二</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90%E4%BA%8C/"/>
    <id>http://zhangzemiao.com/Java并发编程/Fork-Join框架使用与分析二/</id>
    <published>2016-12-13T07:50:20.000Z</published>
    <updated>2020-12-17T07:44:38.899Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了Fork/Join的无返回任务，并尝试解读源码，发现用了很多巧妙的位运算，理解源码时，比较费劲，放弃源码分析。</p><h2 id="样例二"><a href="#样例二" class="headerlink" title="样例二"></a>样例二</h2><p>模拟在文档中查找关键字</p><h3 id="Document类"><a href="#Document类" class="headerlink" title="Document类"></a>Document类</h3><p>模拟文档内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line"><span class="comment">//模拟的词组</span></span><br><span class="line"><span class="keyword">private</span> String words[] = &#123;<span class="string">"the"</span>,<span class="string">"hello"</span>,<span class="string">"goodbye"</span>,</span><br><span class="line"><span class="string">"packt"</span>,<span class="string">"java"</span>,<span class="string">"thread"</span>,<span class="string">"pool"</span>,<span class="string">"random"</span>,<span class="string">"class"</span>,<span class="string">"main"</span>&#125;;</span><br><span class="line"><span class="comment">//创建二维数组</span></span><br><span class="line"><span class="keyword">public</span> String[][] generateDocument(<span class="keyword">int</span> numLines, <span class="keyword">int</span> numWords, String word) &#123;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">String document[][] = <span class="keyword">new</span> String[numLines][numWords];</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numLines; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numWords; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = random.nextInt(words.length);</span><br><span class="line">document[i][j] = words[index];</span><br><span class="line">                <span class="comment">//记录查找关键字的个数，方便运行结束后进行比对</span></span><br><span class="line"><span class="keyword">if</span> (document[i][j].equals(word)) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"DocumentMock: The word appears "</span>+ counter+<span class="string">" times in the document"</span>);</span><br><span class="line">    <span class="keyword">return</span> document;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DocumentTask"><a href="#DocumentTask" class="headerlink" title="DocumentTask"></a>DocumentTask</h3><p>继续RecursiveTask，支持返回类型。这个任务解决一维（文档）的问题，二维（行）的问题交给LineTask来执行。任务类要有分解任务的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String document[][];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> start, end;</span><br><span class="line"><span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DocumentTask</span><span class="params">(String document[][], <span class="keyword">int</span> start, <span class="keyword">int</span> end, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.document = document;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line"><span class="keyword">this</span>.word = word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//符合特定条件，不用分解任务，这里将计算交给的另外的任务</span></span><br><span class="line"><span class="keyword">if</span> (end - start &lt; <span class="number">10</span>) &#123;</span><br><span class="line">result = processLines(document, start, end, word);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="comment">//分解任务，合并计算结果</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">DocumentTask task1 = <span class="keyword">new</span> DocumentTask(document, start, mid, word);</span><br><span class="line">DocumentTask task2 = <span class="keyword">new</span> DocumentTask(document, mid, end, word);</span><br><span class="line">invokeAll(task1, task2);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = groupResults(task1.get(), task2.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">processLines</span><span class="params">(String[][] document, <span class="keyword">int</span> start, <span class="keyword">int</span> end, String word)</span> </span>&#123;</span><br><span class="line">List&lt;LineTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;LineTask&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">LineTask task = <span class="keyword">new</span> LineTask(document[i], <span class="number">0</span>, document[i].length, word);</span><br><span class="line">tasks.add(task);</span><br><span class="line">&#125;</span><br><span class="line">invokeAll(tasks);</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</span><br><span class="line">LineTask task = tasks.get(i);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = result + task.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">groupResults</span><span class="params">(Integer number1, Integer number2)</span> </span>&#123;</span><br><span class="line">Integer result;</span><br><span class="line">result = number1 + number2;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LineTask"><a href="#LineTask" class="headerlink" title="LineTask"></a>LineTask</h3><p>用来解决行中查找关键字的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> String line[];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> start, end;</span><br><span class="line"><span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LineTask</span><span class="params">(String line[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.line = line;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line"><span class="keyword">this</span>.word = word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Integer result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (end - start &lt; <span class="number">100</span>) &#123;</span><br><span class="line">result = count(line, start, end, word);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">LineTask task1 = <span class="keyword">new</span> LineTask(line, start, mid, word);</span><br><span class="line">LineTask task2 = <span class="keyword">new</span> LineTask(line, mid, end, word);</span><br><span class="line">invokeAll(task1, task2);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = groupResults(task1.get(), task2.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">count</span><span class="params">(String[] line, <span class="keyword">int</span> start, <span class="keyword">int</span> end, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (line[i].equals(word)) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">groupResults</span><span class="params">(Integer number1, Integer number2)</span> </span>&#123;</span><br><span class="line">Integer result;</span><br><span class="line">result = number1 + number2;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Document mock = <span class="keyword">new</span> Document();</span><br><span class="line">    String[][] document = mock.generateDocument(<span class="number">100</span>, <span class="number">1000</span>, <span class="string">"the"</span>);</span><br><span class="line">    DocumentTask task = <span class="keyword">new</span> DocumentTask(document, <span class="number">0</span>, <span class="number">100</span>, <span class="string">"the"</span>);</span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    pool.execute(task);</span><br><span class="line">    <span class="comment">//等待任务完成</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"******************************************\n"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"Main: Parallelism: %d\n"</span>, pool.getParallelism());</span><br><span class="line">        System.out.printf(<span class="string">"Main: Active Threads: %d\n"</span>, pool.getActiveThreadCount());</span><br><span class="line">        System.out.printf(<span class="string">"Main: Task Count: %d\n"</span>, pool.getQueuedTaskCount());</span><br><span class="line">        System.out.printf(<span class="string">"Main: Steal Count: %d\n"</span>, pool.getStealCount());</span><br><span class="line">        System.out.printf(<span class="string">"******************************************\n"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!task.isDone());</span><br><span class="line"></span><br><span class="line">    pool.shutdown();</span><br><span class="line">    <span class="comment">//等待任务关闭完成</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pool.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Main: The word appears %d in the document"</span>, task.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是第二篇介绍Fork/Join，但是没有花时间再去研究源码，付出和收获不成正比，大概知道Fork/Join的基本原理，理解背后的设计。这里有篇<a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="noopener">参考文章</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇介绍了Fork/Join的无返回任务，并尝试解读源码，发现用了很多巧妙的位运算，理解源码时，比较费劲，放弃源码分析。&lt;/p&gt;
&lt;h2 id=&quot;样例二&quot;&gt;&lt;a href=&quot;#样例二&quot; class=&quot;headerlink&quot; title=&quot;样例二&quot;&gt;&lt;/a&gt;样例二&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fork/Join框架使用与分析</title>
    <link href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://zhangzemiao.com/Java并发编程/Fork-Join框架使用与分析/</id>
    <published>2016-12-05T02:11:27.000Z</published>
    <updated>2020-12-17T07:44:38.899Z</updated>
    
    <content type="html"><![CDATA[<p>Fork/Join框架，用来解决某些特定任务，而这些任务可以分解成小任务，去执行小任务，合并结果。</p><h2 id="样例一"><a href="#样例一" class="headerlink" title="样例一"></a>样例一</h2><p>价格更新，mock批量的价格类（Product），然后创建任务Task（继承RecursiveAction），将Task由ForkJoinPool执行，更新价格。</p><h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><p>Product类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ProductListGenerator类，mock指定大小的product list，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductListGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">List&lt;Product&gt; ret = <span class="keyword">new</span> ArrayList&lt;Product&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">Product product = <span class="keyword">new</span> Product();</span><br><span class="line">product.setName(<span class="string">"Product "</span> + i);</span><br><span class="line">product.setPrice(<span class="number">10</span>);</span><br><span class="line">ret.add(product);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Task类，继承RecursiveAction类，该任务没有返回结果，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> increment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Task</span> <span class="params">(List&lt;Product&gt; products, <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">double</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.products=products;</span><br><span class="line">    <span class="keyword">this</span>.first=first;</span><br><span class="line">    <span class="keyword">this</span>.last=last;</span><br><span class="line">    <span class="keyword">this</span>.increment=increment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Task被调度的方法，这里有拆分任务的逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接计算</span></span><br><span class="line"><span class="keyword">if</span> (last - first &lt; <span class="number">10</span>) &#123;</span><br><span class="line">updatePrices();</span><br><span class="line">        <span class="comment">//拆解任务</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> middle = (last + first) / <span class="number">2</span>;</span><br><span class="line">System.out.printf(<span class="string">"Task: Pending tasks: %s\n"</span>, getQueuedTaskCount());</span><br><span class="line">Task t1 = <span class="keyword">new</span> Task(products, first, middle + <span class="number">1</span>, increment);</span><br><span class="line">Task t2 = <span class="keyword">new</span> Task(products, middle + <span class="number">1</span>, last, increment);</span><br><span class="line">invokeAll(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePrices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=first; i&lt;last; i++)&#123;</span><br><span class="line">      Product product=products.get(i);</span><br><span class="line">      product.setPrice(product.getPrice()*(<span class="number">1</span>+increment));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Main方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ProductListGenerator generator = <span class="keyword">new</span> ProductListGenerator();</span><br><span class="line">    List&lt;Product&gt; products = generator.generate(<span class="number">10000</span>);</span><br><span class="line">    Task task=<span class="keyword">new</span> Task(products, <span class="number">0</span>, products.size(), <span class="number">0.20</span>);</span><br><span class="line">    ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    pool.execute(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Main: Thread Count: %d\n"</span>, pool.getActiveThreadCount());</span><br><span class="line">        System.out.printf(<span class="string">"Main: Thread Steal: %d\n"</span>, pool.getStealCount());</span><br><span class="line">        System.out.printf(<span class="string">"Main: Parallelism: %d\n"</span>, pool.getParallelism());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!task.isDone());</span><br><span class="line"></span><br><span class="line">    pool.shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task.isCompletedNormally()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Main: The process has completed normally.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; products.size(); i++) &#123;</span><br><span class="line">        Product product = products.get(i);</span><br><span class="line">        <span class="keyword">if</span> (product.getPrice() != <span class="number">12</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Product %s: %f\n"</span>, product.getName(), product.getPrice());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Main: End of the program.\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>ForkJoinPool</p><h4 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h4><p>并行度：最大为32767（MAX_CAP），最小是运行CPU个数。<br>使用默认的线程工厂<br>异常处理，默认为null，没有处理<br>异步模式， true为FIFO，false为LIFO。背后的含义要分析。<br>ctl字段，在成功添加任务后，需要这个字段来做判断。如果并行度为4，ctl则为一个负数（-844442110001152）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">         defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                         String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="comment">//这里，将ctl初始化为一个负数，这个负数转换成int后，是0。这数学的设计。。。</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h4><p>ForkJoinPool提供execute方法，添加任务并执行。此为ForkJoinPool也是Executor，提供submit方法，支持ForkJoinTask和Runnable（Runnable包装成ForkJoinTask）两种task。<br>创建好ForkJoinPool后，就可以提交任务执行了。那么提交任务的逻辑中包括的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用逻辑，ForkJoinPool.execute(task) –&gt; externalPush(task) –&gt; externalSubmit(task)。业务代码都集中在externalSubmit方法中。runState如果小于0，意味着ForkJoinPool已被终止，不接受任务了，抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果runState是0，说明未初始化，进行初始化，创建workQueues。workQueues的大小是CPU个数的两倍（自己根据代码算是这样的，不能保证正确）。<br><strong>这里只进行workQueues数组的初始化，提交的task还没处理。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">         ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先锁上RSLOCK，通过Unsafe的CAS，锁上标记位RSLOCK</span></span><br><span class="line">    rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否已经初始化，正常（不考虑并发）情况是0。</span></span><br><span class="line">        <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">            U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                                   <span class="keyword">new</span> AtomicLong());</span><br><span class="line">            <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">            <span class="comment">//默认情况，P是当前主机CPU单元的个数</span></span><br><span class="line">            <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">            <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">            n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//自己算了下，如果CPU是4个，那么队列的size是8。</span></span><br><span class="line">            workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">            ns = STARTED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//unlock方法会更新runState, runState为4</span></span><br><span class="line">        unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>externalSubmit方法中，弄了个死循环，所以逻辑还得继续走。再进行runState的状态判断逻辑。<br>如果runState还是为0，初始化一个WorkQueue。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// create new queue</span></span><br><span class="line">    q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">    q.hint = r;</span><br><span class="line">    q.config = k | SHARED_QUEUE;</span><br><span class="line">    q.scanState = INACTIVE;</span><br><span class="line">    rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">        ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">    unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一种情况，当workQueus数组的指定下标()不为null，将task放入这个WorkQueue。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为嘛是k = r &amp; m &amp; SQMASK，再研究</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//给当前的队列加锁</span></span><br><span class="line">    <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">        <span class="keyword">int</span> s = q.top;</span><br><span class="line">        <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">        <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">            <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">            <span class="comment">//growArray方法进行initial或者双倍扩容</span></span><br><span class="line">                (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                U.putOrderedObject(a, j, task);</span><br><span class="line">                U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                submitted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果task成功提交，会尝试启动worker，来看看是怎么设计的</span></span><br><span class="line">        <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">            signalWork(ws, q);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>signalWork方法，添加task成功后调用。tryAddWorker方法会创建一个ForkJoinWorkerThread，并绑定这个ForkJoinPool和其中的一个队列WorkQueue。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="comment">//这里初始化后的ctl是个负数，但是转换成int后，变成0，很巧的数学设计</span></span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                <span class="comment">//初始状态，会调用这个方法，调用完退出</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到最初的使用ForkJoinPool的代码，new一个，然后execute添加任务。我们分析了ForkJoinPool初始化过程。但是具体的执行，要在继续分析，看源码。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>理解ThreadLocalRandom.getProbe()和ThreadLocalRandom.advanceProbe(r)的使用，这个方法并非公开的API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Fork/Join框架，用来解决某些特定任务，而这些任务可以分解成小任务，去执行小任务，合并结果。&lt;/p&gt;
&lt;h2 id=&quot;样例一&quot;&gt;&lt;a href=&quot;#样例一&quot; class=&quot;headerlink&quot; title=&quot;样例一&quot;&gt;&lt;/a&gt;样例一&lt;/h2&gt;&lt;p&gt;价格更新，mock
      
    
    </summary>
    
      <category term="Java并发编程" scheme="http://zhangzemiao.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Queue队列分析</title>
    <link href="http://zhangzemiao.com/CoreJava/Java%E4%B8%AD%E7%9A%84Queue%E9%98%9F%E5%88%97%E5%88%86%E6%9E%90/"/>
    <id>http://zhangzemiao.com/CoreJava/Java中的Queue队列分析/</id>
    <published>2016-11-28T09:17:39.000Z</published>
    <updated>2020-12-17T07:44:38.900Z</updated>
    
    <content type="html"><![CDATA[<p>JavaSE中，Collection是非常重要的一部分内容，也是源码看得最多的。<a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">江南白衣</a>也更新了它的集合小抄这文章，沿着他的思路，我也整理整理。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li><p>Iterable接口，支持foreach操作，迭代支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Collection接口，定义集合类的公共方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Query Operations</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modification Operations</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//remove jdk 1.8 feature</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Queue接口，队列的顶层接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，我把JDK 1.8的相关代码去掉了</strong></p><p><img src="http://photos.zhangzemiao.com/blog_java_queue.jpg" alt></p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>集合操作，Collection接口和Queue接口都有定义，来看看有啥区别。我们以LinkedList类为例，发现LinkedList不靠谱，加入ArrayBlockingQueue做对比。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>Collection.add(Queue也定义的add方法，override)和Queue.offer。<br>LinkedList类实现，发现两个方法实现没有区别。在Java API中，有段描述，Collection的add方法，在添加元素失败后，会抛出unchecked异常。而offer方法，被设计成添加失败为正常，不抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//插入链尾</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ArrayBlockingQueue中，采用的是API描述的逻辑，代码如下<br>add方法，调用AbstractQueue抽象类的add方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer方法，只有在元素为null时，抛出空指针异常，其他情况不抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满了，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除元素，Queue.remove()和Queue.poll()。API中描述，两者的区别，在于当队列为空时，remove抛出异常，poll方法返回null。而Collection.remove(Object),不做对比，remove成功返回true，remove失败返回false。<br>ArrayBlockingQueue的remove()方法，没有实现，沿用AbstractQueue抽象类的公共方法，会抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ArrayBlockingQueue的poll()方法，不会抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>Queue.element和Queue.peek方法，element和peek方法都是获取但不删除。element方法，如果没有元素，则抛异常。peek方法，如果没有元素，则返回null。<br>ArrayBlockingQueue的element()方法，没有实现，沿用AbstractQueue抽象类的公共方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = peek();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ArrayBlockingQueue的peek方法，不会抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="具体队列的实现分析"><a href="#具体队列的实现分析" class="headerlink" title="具体队列的实现分析"></a>具体队列的实现分析</h2><p>在类图中，省略的很多具体的实现类，双向队列Dequeue和并发的队列，后续单独分析。LinkedList可以作为队列，也可以作为链表，这里不做过多分析。重点看看ArrayBlockingQueue和LinkedBlockingQueue。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>顾名思义，底层由数组实现的阻塞队列。怎么阻塞？采用ReentrantLock，根据上面贴的代码，已经看出来了，等待唤醒，使用ReentrantLock的Condition控制，一个notEmpty，一个notFull。<strong>没有进行扩容处理。</strong></p><h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>poll方法不会阻塞，take方法获取元素，会阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">//获取元素，会唤醒notFull的等待线程</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>add和offer方法，添加元素不会阻塞，put为阻塞方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//插入元素后，会唤醒notEmpty的阻塞线程</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>底层由分散的结点组成链表，默认为Integer.Max_VALUE长度，有一个头结点，尾结点。take和put采用各自的ReentrantLock，为嘛会搞两把锁？跟ArrayBlockingQueue（只有一把锁）不一样。</p><h4 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h4><p>offer方法，不阻塞<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入空元素，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//原子类，计数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//如果队列满，立即返回false，不阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">//插入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer超时等待方法，队列满了，会等待超时时间，其他情况不阻塞，支持中断相应。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//支持中断相应</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满，超时等待notFull</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p>put方法，阻塞插入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满，等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入队列</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//count自增，注意，返回的是更新前的值</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//如果未满，唤醒可能还有插入的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果队列初始的size为0，那么可能会有阻塞的take线程，这里唤醒take线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取take锁，唤醒等待的take线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="take-1"><a href="#take-1" class="headerlink" title="take"></a>take</h4><p>take方法，阻塞获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列空，等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取头结点</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">//自增，返回先前的值</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果队列有大于1的个数，继续唤醒take线程，进行操作</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果先前的队列是满的，那么可能会有put的阻塞线程，唤醒它们</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取写锁，唤醒阻塞的put线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="临界分析"><a href="#临界分析" class="headerlink" title="临界分析"></a>临界分析</h4><p>为什么LinkedBlockingQueue可有两个锁呢，想了一下，一个队尾插入，一个队头获取，互不干扰。只有在一些临界条件，会相互影响一下。<br>当队列为空的时候，也就是刚刚初始化后，Head和Tail共同指向一个Null结点。如果进行take操作，所有线程进入take锁的notEmpty条件阻塞线程。如果进行put操作，Head指向Null结点，Null结点指向新结点，tail指向新节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//默认会有Null结点，头尾均指向它</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链尾插入新结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当队列满了，如果继续插入元素，put线程加入notFull条件中阻塞队列。take线程来，从链头拿元素，默认第一个元素是null的，take操作，head指向下一个结点，并返回结点中的元素，然后将元素设置为null。这样头结点又变成了Null结点。然后唤醒put阻塞线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    <span class="comment">//head默认是个null结点</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">//原始头结点自己指向自己</span></span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//第一个存储元素的结点，作为头结点</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">//拿出新的头结点的元素</span></span><br><span class="line">    E x = first.item;</span><br><span class="line">    <span class="comment">//设置新的头结点的元素为null，变成Null结点</span></span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaSE中，Collection是非常重要的一部分内容，也是源码看得最多的。&lt;a href=&quot;http://calvin1978.blogcn.com/articles/collection.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;江南
      
    
    </summary>
    
      <category term="CoreJava" scheme="http://zhangzemiao.com/categories/CoreJava/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
      <category term="Queue" scheme="http://zhangzemiao.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>SpringCache与Guava结合使用</title>
    <link href="http://zhangzemiao.com/%E7%BC%93%E5%AD%98/SpringCache%E4%B8%8EGuava%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhangzemiao.com/缓存/SpringCache与Guava结合使用/</id>
    <published>2016-11-22T10:11:09.000Z</published>
    <updated>2020-12-17T07:44:38.905Z</updated>
    
    <content type="html"><![CDATA[<p>少废话，上菜。</p><h2 id="启动Spring-Cache机制"><a href="#启动Spring-Cache机制" class="headerlink" title="启动Spring Cache机制"></a>启动Spring Cache机制</h2><p>默认情况，使用Spring without configuration方式，我的测试代码在<a href="http://git.oschina.net/zhangzemiao/FindWeb" target="_blank" rel="noopener">这里</a>。官方讲解Spring Cache在<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html" target="_blank" rel="noopener">这里</a>。</p><ol><li>引用依赖<br>如果是Spring Boot项目，可以参考<a href="https://spring.io/guides/gs/caching/" target="_blank" rel="noopener">这里</a>，<br>gradle,<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">"org.springframework.boot:spring-boot-starter-cache"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>maven,<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>我测试是用的Spring Boot项目，但是没有用Spring Boot组件，而是引用Spring Context Support来支持Guava。<br>gradle,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">"org.springframework:spring-context-support"</span>)</span><br></pre></td></tr></table></figure></p><ol start="2"><li>启动Cache Configuration<br>@Configuration<br>@EnableCaching<br>public class SecureTomcatConfiguration {<br> …<br>}</li><li>添加CacheManager<br>我使用Spring提供的GuavaCacheManager，参数设置一个或多个Cache，如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GuavaCacheManager cacheManager = <span class="keyword">new</span> GuavaCacheManager(<span class="string">"trades"</span>);</span><br><span class="line">    cacheManager.setCacheBuilder(CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">60</span> , TimeUnit.SECONDS)</span><br><span class="line">            .maximumSize(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果你想设置不同的size和过期时间的Cache，可以使用SimpleCacheManager，设置GuavaCache的List，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleCacheManager manager = <span class="keyword">new</span> SimpleCacheManager();</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(GuavaCache one);</span><br><span class="line">    list.add(GuavaCache two);</span><br><span class="line">    ...</span><br><span class="line">    manager.setCaches(  list )</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>使用Cache<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"trades"</span>, key = <span class="string">"#key"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeAccount <span class="title">getTradeAccountById</span><span class="params">(String key,String owner,<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"invoke getTradeAccountById method :"</span>+ (++COUNT));</span><br><span class="line">    TradeAccount mock = <span class="keyword">new</span> TradeAccount();</span><br><span class="line">    mock.setId(key);</span><br><span class="line">    mock.setBalance(balance);</span><br><span class="line">    mock.setOwner(owner);</span><br><span class="line">    <span class="keyword">return</span> mock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h2><p>在上述的代码中，@Cacheable里有包含key属性，指定的哪个参数作为key，作为唯一性的判断。如果没有指定key，那么所有的参数都会作为keys，然后判断keys的hashCode和equals方法，官方默认实现，见如下分析，<br>你还可以自己实现KeyGenerator接口，设置自己的KeyGenerator，然后在@Cacheable使用，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class MyKeyGenerator implements KeyGenerator&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"books"</span>, keyGenerator=<span class="string">"myKeyGenerator"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">method</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看了Spring 4.0以上，Default Key Generation，SimpleKeyGenerator。默认的Key Generator会将所有的参数包装成一个 SimpleKey。然后依据这个SimpleKey的hashcode和equals方法判断唯一性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> generateKey(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate a key based on the specified parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generateKey</span><span class="params">(Object... params)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果无参，则用返回EMPTY对象</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(params.length == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SimpleKey.EMPTY;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//如果只有一个参数，就返回当前参数作为Key对象</span></span><br><span class="line"><span class="keyword">if</span> (params.length == <span class="number">1</span>) &#123;</span><br><span class="line">Object param = params[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; !param.getClass().isArray()) &#123;</span><br><span class="line"><span class="keyword">return</span> param;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//其他情况，则返回SimpleKey对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleKey(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleKey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里构造SimpleKey，保存所有参数，然后使用Arrays.deepHashCode，作为新对象的hashcode</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> SimpleKey&#125; instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elements the elements of the key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleKey</span><span class="params">(Object... elements)</span> </span>&#123;</span><br><span class="line">Assert.notNull(elements, <span class="string">"Elements must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.params = <span class="keyword">new</span> Object[elements.length];</span><br><span class="line">System.arraycopy(elements, <span class="number">0</span>, <span class="keyword">this</span>.params, <span class="number">0</span>, elements.length);</span><br><span class="line"><span class="keyword">this</span>.hashCode = Arrays.deepHashCode(<span class="keyword">this</span>.params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * equals方法，最终使用Arrays.deepEquals比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj || (obj <span class="keyword">instanceof</span> SimpleKey</span><br><span class="line">&amp;&amp; Arrays.deepEquals(<span class="keyword">this</span>.params, ((SimpleKey) obj).params)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 直接返回hashcode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注解-Cacheable参数分析"><a href="#注解-Cacheable参数分析" class="headerlink" title="注解@Cacheable参数分析"></a>注解@Cacheable参数分析</h2><p>1.cacheManager<br>这个参数指定CacheManager，没有使用。<br>2.cacheNames<br>指定哪个使用哪个cache<br>3.cacheResolver<br>这个没有深入研究，忽略。<br>4.condition<br>条件限制，这个判断是在方法执行前，决定是否缓存。<br>5.key<br>指定存储的Key，默认是方法的所有参数组成keys。<br>6.keyGenerator<br>KeyGenerator，默认是所有参数keys，生成一个SimpleKey，作为Cache对象的Key。<br>7.sync<br>未研究，可参考官方文档。<br>8.unless<br>这个是方法执行后，解析结果，过滤。<br>9.value<br>跟cacheNames功能一样，别名使用。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果要灵活使用Spring Cache的注解方法，需要熟悉Spring EL，方便灵活的刷选结果进行缓存。还有其他的注解进行缓存，这里就没介绍了，更多详细的，可以研究Spring Cache官方文档和其他资料。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;少废话，上菜。&lt;/p&gt;
&lt;h2 id=&quot;启动Spring-Cache机制&quot;&gt;&lt;a href=&quot;#启动Spring-Cache机制&quot; class=&quot;headerlink&quot; title=&quot;启动Spring Cache机制&quot;&gt;&lt;/a&gt;启动Spring Cache机制&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="缓存" scheme="http://zhangzemiao.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="Java" scheme="http://zhangzemiao.com/tags/Java/"/>
    
      <category term="缓存" scheme="http://zhangzemiao.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
